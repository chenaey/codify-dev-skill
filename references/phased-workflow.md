# 分步实现流程

> **路径 B 专用**：当 SKILL.md Step 3 判定为"复杂"时，必须执行本流程。

---

## 核心约束

**禁止一次性生成所有代码。**

必须：先理解 → 再规划 → 逐个思考 → 逐个实现

| 禁止 | 必须 |
|------|------|
| 判断复杂后一次性生成所有代码 | 逐区域获取 JSON、逐区域生成代码 |
| 跳过 Phase 1-2 直接写代码 | 先输出理解和计划，再实现 |
| 实现部分区域就结束 | 所有区域状态为 [✓] 才算完成 |

---

## Phase 1: 理解骨架

获取骨架后，**先输出你的理解**：

```markdown
## 骨架理解

**整体结构**：
- 根容器包含 N 个主要区域
- 布局方向：垂直排列 / 水平排列 / 混合

**识别到的区域**：
1. 节点 13:4000 [V] - 看起来是...
2. 节点 13:4382 [H] - 看起来是...
3. ...

**重复模式**：
- 节点 13:4382 下有 ×3 重复，可能是列表/卡片/选项

**不确定的部分**：
- 节点 XX 的用途不明确，需要结合截图或获取详细 JSON 确认
```

**完整性检查**：骨架中每个 ID 都必须理解，防止遗漏。


---

## Phase 2: 制定实现计划

必须创建 `implementation-plan.md`，包含**接口设计**、**组件规划**和**实现思路**：

```markdown
# 实现计划

## 接口设计

> 从骨架推导数据接口，设计稿值作为示例数据。

```typescript
// 从 ×3 重复结构推导
interface CardItem {
  icon: string    // ICON 节点
  title: string   // TEXT 节点
}

// 组件 Props
interface CardListProps {
  items: CardItem[]
}

interface HeaderProps {
  title: string
  description?: string
}
```

## 组件列表

| 组件 | 节点 ID | 功能描述 | 特殊处理 | 依赖 | 状态 |
|------|---------|---------|---------|------|------|
| Header | 1:2 | 顶部导航区域 | 可能有固定定位 | - | [ ] |
| CardList | 1:3 | 横向卡片列表 | 包含 ×3 重复，需提取模板 | Card | [ ] |
| Card | (子节点) | 单个卡片 | 是 CardList 的模板 | - | [ ] |
| Footer | 2:3 | 底部信息 | - | - | [ ] |

## 实现顺序

1. **Card** - 先实现子组件，被 CardList 依赖
2. **CardList** - 使用 Card 组件
3. **Header** - 独立区域
4. **Footer** - 独立区域
5. **Page** - 组装所有组件

## 组件详细描述

### Card (子节点 of 13:4382)
- **Props**：`CardItem`（icon, title）
- **结构**：ICON + TEXT 组合
- **预期实现**：图标 + 文字横排，可能有点击态
- **注意**：图标需下载 SVG

### CardList (13:4382)
- **Props**：`CardListProps`（items 数组）
- **结构**：水平布局容器，包含 3 个 Card
- **预期实现**：flex 横向排列，循环渲染 Card

### Header (13:4000)
- **Props**：`HeaderProps`（title, description）
- **结构**：垂直布局，标题 + 描述
- **预期实现**：简单的标题组件

### Footer (17:6940)
- **Props**：无（静态内容）或 `{ text: string }`
- **结构**：简单文本区域
- **预期实现**：底部信息展示
```

**计划要素说明**：

| 字段 | 作用 |
|------|------|
| 功能描述 | 这个组件做什么（不是长什么样） |
| 特殊处理 | 需要特别注意的点（重复、定位、资源下载） |
| 依赖 | 是否依赖其他组件 |
| 实现顺序 | 被依赖的先实现 |
| 预期实现 | 用自然语言描述代码思路 |

---

## Phase 3: 逐个实现

按计划实现每个组件：

### 3.1 获取完整 JSON

```bash
curl -s -X POST http://127.0.0.1:13580/get_design \
  -H "Content-Type: application/json" \
  -d '{"node_id": "13:4382"}'
```

### 3.2 实现前描述（强制）

- 复杂设计必须拆分为多个合理组件文件，职责单一，同时组件设计合理的输入接口，最终组装。
- 注意组件跟组件之间的边界关系 边距信息等 不要遗漏关键样式

**在写代码之前**，先描述实现思路，必须输出以下内容：
```markdown
## [组件名] 实现描述

**骨架片段**（复制相关骨架）：
```
FRAME [H] 944:045528
├─ FRAME [V] 377:65990   ← 位置 1
└─ INSTANCE 1022:054062  ← 位置 2
```

> 组件UI结构顺序必须与骨架位置保持一致

**骨架子节点清单**：
| 类型 | 节点 ID | 说明 | 需下载 |
|------|---------|------|--------|
| ICON | 11 | 说明 | ✓ SVG |
| TEXT | 22 | 说明 | - |
| ICON | 33 | 说明 | ✓ SVG |

**结构**：
- 外层容器：flex 横向
- 左侧：24x24 图标，从 assets 下载
- 右侧：文本，从 text.content 提取

**样式来源**
- 容器 padding：customStyle.padding → `padding: 12px`
- gap：customStyle.gap → `gap: 8px`
- 文本颜色：customStyle.color → `color: #FFF`
- 圆角：customStyle["border-radius"] → `border-radius: 12px`

**资源下载**：
- 图标 1:2 → `icon-back.svg`
- 图标 1:3 → `icon-link.svg`
```

**检查清单**（实现前自检）：
- [ ] 骨架中的每个子节点都已列出
- [ ] 每个 ICON 节点都标记了下载需求
- [ ] 文本内容从 `text.content` 提取，非猜测

### 3.3 生成代码

遵循 [codegen-rules.md](codegen-rules.md) 生成代码。

### 3.4 更新计划

```markdown
| Card | (子节点) | 单个卡片 | ... | - | [✓] |
```

---

## Phase 4: 组装 + 覆盖检查

所有组件完成后：

1. 创建页面入口，组合组件
2. 检查组件间的 props 传递
3. **骨架覆盖检查**：

```markdown
| 骨架关键节点 | 已实现 | 备注 |
|-------------|--------|------|
| 377:62671 (背景) | [ ] | 需下载图片 |
| 944:045528 (主体) | [✓] | MainContent |
| ... | ... | ... |
```

> 存在 [ ] 时，说明原因或补充实现

---

## 过程检查

> 实现过程中持续检查，完成后返回 SKILL.md Step 6 执行终态验证。

| 检查项 | 时机 |
|--------|------|
| 输出骨架理解 | Phase 1 完成时 |
| 创建实现计划（含功能描述、特殊处理） | Phase 2 完成时 |
| 依赖组件先实现 | Phase 3 每个组件前 |
| 输出实现描述 | Phase 3 每个组件前 |
| 复杂 JSON 进一步拆分 | Phase 3 获取 JSON 后 |
| 重复结构用循环 | Phase 3 生成代码时 |
